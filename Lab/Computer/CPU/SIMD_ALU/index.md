---
title: 74181 で SIMD ALU を作る
---

## SIMD

CPU の SIMD (Single Instruction Multiple Data) 命令とは、一つの命令で複数のデータを処理する命令のことです。

例えば、Intel の AVX や Arm の NEON といった拡張命令があります。

以下は、AVX 命令を使った C 言語のプログラムの例です。
256 ビット幅のレジスタを使って、8 つの 32 ビット整数を一度に処理する命令です。

```c:
#include <immintrin.h>
#include <stdio.h>

int main() {
    // 配列を用意 (32 bit int x 8 = 256 bit)
    int a[8] = {1, 2, 3, 4, 5, 6, 7, 8};
    int b[8] = {10, 20, 30, 40, 50, 60, 70, 80};
    int result[8];

    // AVXレジスタにデータをロード
    __m256i avx_a = _mm256_loadu_si256((__m256i*)a);
    __m256i avx_b = _mm256_loadu_si256((__m256i*)b);

    // 並列加算
    __m256i avx_result = _mm256_add_epi32(avx_a, avx_b);

    // 結果を配列にストア
    _mm256_storeu_si256((__m256i*)result, avx_result);

    // 結果を表示
    printf("Result: ");
    for (int i = 0; i < 8; i++) {
        printf("%d ", result[i]);
    }
    printf("\n");

    return 0;
}
```

SIMD 命令を

![](./img/simd.dio.svg)

例えば 64bit の CPU の場合、基本的には 64bit の整数どうしの演算ができます。しかし、8bit までしか使わない場合、64bit の上位 56bit の演算器は暇する。

要するに、大きい幅のレジスタを、小さい幅のレジスタの集合とみなして、演算を行う命令です。こうすることで、遊んでいた MSB 側の演算器を効率的に使うことができるようになります。

## ロジック IC での実装

↑ の図を見てわかる通り、演算器間のキャリーを接続したら単一の演算器、キャリーを外したら複数の演算器ということになりますね。

ということで作ってみました。基本的に、74181・74182 のアプリケーションノートに書いてある通りの回路です。

![](./img/alu.dio.svg)

キャリーを接続するかしないかを、74 マルチプレクサで切り替えます。

## 8bit 単位でやってみる

74182 をハックする必要があります。

## まとめ

いかがでしたか？

自作 CPU に取り入れてみてはいかがでしょうか？
