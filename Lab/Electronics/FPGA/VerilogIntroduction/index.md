---
title: Verilog超入門
---

最近、Verilog に関する質問を受けることが多くなってきたので、まとめておきます。

## Verilog は状態関係記述言語である

Verilog わからん！て聞いてくる大半の人が、基本的な勘違いをしています。

> wire reg は変数

まず、Verilog は回路を記述する言語なので、変数というものはありません。
回路にあるのは部品と配線です。

> reg がフリップフロップ wire が配線に対応する

これも嘘です。元々 Verilog は回路を記述する言語で、この対応が存在しました。
しかし、実質的に論理回路を書くための言語として使われて続けた結果、この対応は形骸化しています。

このことを理解するには、論理回路を 1 段抽象化して、「状態の関係」を表したグラフとして見る必要があります。

### 回路と状態

これは、A と B を AND に入力し出力を C につなぐという回路です。

```
-A-|
   AND-C-
-B-|
```

これを Verilog で書くと、こうなります。

```
module AND(
    input  wire A,
    input  wire B,
    output wire C
);
assign C = A & B;
endmodule
```

「C の値は、A と B の値によって定まる」と読むことができます。

| 回路図     | 状態関係 | Verilog |
| ---------- | -------- | ------- |
| 配線       | 状態変数 | wire    |
| 論理ゲート | 依存関係 | assign  |

Verilog では、論理回路を状態の依存関係として記述しています。

### reg は何か

上の回路を、Verilog ではこのように書くこともできます。

```
module AND(
    input  wire A,
    input  wire B,
    output reg  C
);
always @(*) begin
    C <= A & B;
end
endmodule
```

これを、愚直に回路図に書いてみると、こうなります。

```
-A-----|
   |   AND-[C]-
-B-----|    ^
 | |        |
 | +--------|
 +----------|
```

A と B の AND が C のレジスタの入力に、A と B がレジスタのクロック入力に入っています。

| 回路図                | 状態関係 | Verilog  |
| --------------------- | -------- | -------- |
| 配線/フリップフロップ | 状態変数 | wire/reg |
| 論理ゲート            | 依存関係 | assign   |

「状態変数の依存関係が変わらない」

wire と reg に **本質的な違いはない！** ← 結論

コンパイラが賢いので、無駄なレジスタは取り除いてくれます。

実際、 System Verilog では、wire と reg をまとめて「logic」とすることができます。System Verilog を使える環境ではそっちを使ったほうが楽です。

## FPGA のしくみ

FPGA がなぜ任意の論理回路に姿を変えることができるのか

### 組合回路

ROM は任意の組み合わせ回路になることができます。

例えば、2 入力 1 出力の 4bit の ROM は、任意の 2 入力の組み合わせ回路になります。

| アドレス | 値  |
| -------- | --- |
| 0b00     | 0   |
| 0b01     | 1   |
| 0b10     | 1   |
| 0b11     | 1   |

0,1,1,1,1 を書き込めば、OR ゲートになりますし、0,0,0,1 を書き込めば、AND ゲートになります。

FPGA は ROM を使って書き換え可能な組み込み回路を実現しています。

### 順序回路

順序回路は、オートマトンで表現できます。

### FPGA の構造

FPGA には、ROM と DFF が大量にあります。

## Verilog を FPGA に書き込むまで

FPGA の正体は、大量のロジックブロックと、それらを接続する大量のスイッチでした。

FPGA に書き込むデータは、

1. LUT に書き込む値
2. スイッチの ON/OFF

を、バイナリ化したものになります。

### Synthesis

ネットリストを出力します。

大きな真理値表を分割し、複数の 4 入力真理値表に組みなおします。

### Place & Route

FPGA のどの LUT にどの組み合わせ回路を割り当てるか、どの FF にどの状態変数を割り当てるか、を設定します。

### Package

ビットストリームを作ります。

## 関数とオートマトン

数学の関数は、入力に対して出力が一意に定まります。
一方、コンピュータにおける関数は、オートマトンです。
これを端的に表現したのが状態遷移図です。
内部状態の違いによって、同じ入力でも違う出力を返します。

## FPGA を使う上での注意

### コンフィグレーション

いままで、FPGA の中には大量の ROM が入ってと言いましたが、本当は違います。SRAM です。電源を切ると消えます。

なので、FPGA の隣には不揮発な ROM があり、ここに FPGA のビットストリームが格納されています。
電源を入れたら、ROM のデータを FPGA 内部の SRAM に送り、FPGA 内部のスイッチ切り替えたり、LUT の値を書き換えたりします。
これをコンフィグレーションといいます。

ビットストリームというのは、FPGA の内部 SRAM が数珠つなぎにクソ長シフトレジスタになっていて、そこにデータを流し込むってイメージです。

自分で FPGA を使って回路を組む場合には、コンフィグレーションに注意する必要があります。リセットって難しい。

### FPGA の IO

FPGA も通常の LSI と同じように、IO バッファがあります。

## System Verilog

System Verilog (Verilog2005) は、Verilog の進化版です。ちょうど C 言語に対する C++のようなイメージです。

古い IDE だとサポートされてなかったりします。

完全に規格に準拠した実装はあまりないです。

### logic

上で述べた通り、wire と reg には本質的な違いはありません。
System Verilog ではこれらの違いを考えずに logic と書けます。

### always_comb

Verilog では、if else による真理値表の記述は、always 中に限られているという制約がありましたが、
SystemVerilog では wire でも if else を使えます。

### interface

上 2 つは Verilog の ~~失敗を修正しただけ~~ 開発当初の思想と現代の使われ方の違いによる矛盾を解消するものですが、
interface はハードウェアの抽象化に重要な機能です。

interface の中にロジックを記述することができ、特にバスを作るときに便利です。
